#pragma kernel GrassCulling

uint instanceCount;
float4x4 vpMatrix;
StructuredBuffer<float4x4> object2Worlds;
AppendStructuredBuffer<float4x4> cullresults;

bool IsInClipSpace(float4 clipSpacePosition)
{
    return clipSpacePosition.x > -clipSpacePosition.w && clipSpacePosition.x < clipSpacePosition.w&&
    clipSpacePosition.y > -clipSpacePosition.w && clipSpacePosition.y < clipSpacePosition.w&&
    clipSpacePosition.z > -1 && clipSpacePosition.z < clipSpacePosition.w;
}

[numthreads(640,1,1)]
void GrassCulling(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= instanceCount)
        return;

    float4x4 o2w = object2Worlds[id.x];
    float4x4 mvp = mul(vpMatrix, o2w);

    static float3 boundMin = float3(-0.2f, 0.0f, -0.3f);
    static float3 boundMax = float3(0.2f, 0.5f, 0.3f);
    float4 boundVerts[8];
    boundVerts[0] = mul(o2w, float4(boundMin, 1));
    boundVerts[1] = mul(o2w, float4(boundMax, 1));
    boundVerts[2] = mul(o2w, float4(boundMax.x, boundMax.y, boundMin.z, 1));
    boundVerts[3] = mul(o2w, float4(boundMax.x, boundMin.y, boundMax.z, 1));
    boundVerts[6] = mul(o2w, float4(boundMax.x, boundMin.y, boundMin.z, 1));
    boundVerts[4] = mul(o2w, float4(boundMin.x, boundMax.y, boundMax.z, 1));
    boundVerts[5] = mul(o2w, float4(boundMin.x, boundMax.y, boundMin.z, 1));
    boundVerts[7] = mul(o2w, float4(boundMin.x, boundMin.y, boundMax.z, 1));

    bool isInClip = false;
    for (int i = 0; i < 8; i++)
    {
        float4 clipspacepos = mul(mvp, boundVerts[i]);
        isInClip = IsInClipSpace(clipspacepos);
    }

    if(isInClip)
        cullresults.Append(o2w);
}
